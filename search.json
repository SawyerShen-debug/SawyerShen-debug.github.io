[{"title":"MySql的介绍和使用","url":"/2022/01/24/1.MySQL%E7%9B%B8%E5%85%B3%E5%9F%BA%E7%A1%80/MySQL%E7%9A%84%E4%BB%8B%E7%BB%8D%E5%92%8C%E4%BD%BF%E7%94%A8/","content":"一、MySQL的背景\n前身属于瑞典的一家公司，MySQL AB\n08年被sun公司收购\n09年sun被oracle公司收购\n\n\n二、MySQL的优点\n开源、免费、成本低\n性能高、移植性也好\n体积小，便于安装\n\n\n三、MySQL的安装属于C&#x2F;S架构的软件，一般来讲安装服务端请移步官网下载，配合workbench使用更佳\n\n四、MySQL启用和停止1.win启用和停止mysql法一：计算机-&gt; 右键管理-&gt; 服务法二：通过管理员身份运行net start 服务名（启动服务）net stop 服务名（停止服务）\n2.mac启用和停止mysql法一：系统偏好设置-&gt;mysql法二：通过terminal-&gt;\n\n启动mysql：sudo /usr/local/mysql/support-files/mysql.server start\n停止mysql：sudo /usr/local/mysql/support-files/mysql.server stop\n\n3.遇到的问题及解决办法1.ERROR! MySQL server PID file could not be found!手动关闭mysql服务在进行启动和停止就可以啦\n2.zsh: command not found: mysql解决方案：\n\n在终端进入目录：&#x2F;usr&#x2F;local&#x2F;bincd /usr/local/bin/\n在终端设置mysql命令路径sudo ln -fs /usr/local/mysql/bin/mysql mysql\n输入mysql -u root -p\n\n\n五、MySQL服务的登录和退出法一：通过mysql自带的客户端只限于root用户\n法二：通过windows自带的客户端\n\n\n登录：\nmysql 【 -h主机名 -P端口号】-u用户名 -p密码\n\n\n退出：\nexit或ctrl+c\n\n\n\n\n六、MySQL的常见命令\n查看当前所有数据库show databases;\n打开指定的库use 库名;\n查看当前库的所有表show tables;\n查看其他库的所有表show tables from 库名;\n创建一个表create table 表名(\t\t列名 列类型，\t\t列名 列类型，\t\t...)\n查看表结构desc 表名;\n查看服务器版本 法一：登录到mysql服务端 select version() 法二：没有登录服务端\n\n\nwin里 mysql -v  mysql -version\n\n\n七、MySQL的语法规范\n不区分大小写，但建议关键字大写，表名，列名小写\n每条命令最好用分号结尾\n每条命令根据需要，可以进行缩进或换行\n注释\n\n\n单行注释：#注释文字\n单行注释：-- 注释文字（记得--后的空格）\n多行注释：/* 注释文字  */\n\n","tags":["MySql基础"]},{"title":"数据库相关概念","url":"/2022/01/23/1.MySQL%E7%9B%B8%E5%85%B3%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/","content":"一、数据库的好处\n实现持久化数据到本地\n使用完整的管理系统统一管理，易于查询（结构化查询）\n\n\n二、DB &amp; DBMS &amp; SQL⭐️1. DB（database）\n数据库\n存储数据的“仓库”&#x2F;容器，它保存了一系列有组织的数据\n\n2. DBMS（database management system）\n数据库管理系统，数据库软件\n用于管理DB中的数据\n数据库是通过DBMS来进行增删改查\n例：mysql、oracle（贵）、DB2、SqlServer（只能在win下）\n\n3. SQL（structure Query Language）\n结构化查询语言\n专门用来与数据库通讯的语言\nSQL的优点：\n1.不是某个特定数据库供应商专有的语言，几乎所有的DBMS都支持SQL\n2.简单易学\n3.虽然简单，但实际上是一个强有力的语言，灵活用其语言元素，可以进行非常复杂和高级的数据库操作\n\n\n\n\n三、数据库存储数据的特点\n将数据放到表中，表再放到库中\n一个数据库中可以有多个表，每个表都有一个名字，用来表示自己，表名具有唯一性\n表具有一些特性，这些特性定义了数据在表中如何存储，类似java中的“类”\n表由列组成，也称为字段。所有表都是由一个或多个列组成的，每一列类似java中的“属性”\n表中的数据是按行存储的，每一行类似java中的“对象”\n\n\n四、常见的数据库管理系统\nmysql\noracle （甲骨文公司）\nDB2（IBM公司）\nsqlserver（微软公司）\n\n","tags":["MySql基础"]},{"title":"分组查询：GROUP BY子句","url":"/2022/02/04/2.DQL%E8%AF%AD%E8%A8%80/%E5%88%86%E7%BB%84%E6%9F%A5%E8%AF%A2%EF%BC%9AGROUP%20%20BY%E5%AD%90%E5%8F%A5/","content":"一、GROUP BY子句语法\n可以使用GROUP BY子句将表中的数据分成若干组SELECT\t分组函数,列(要求出现在group by的后面)FROM\t表名【WHERE\t筛选条件】GROUP BY\t分组的列表【ORDER BY\t排序列表 #ASC/DESC】;\n注意：查询列表必须特殊，要求是分组函数和group by后面出现的字段\n\n\n二、分组查询的具体方法\n分组查询中筛选条件分为两类：\n\n\n\n\n区别\n数据源\n位置｜\n关键字\n\n\n\n分组前筛选\n原始表\ngroup by子句的前面\nwhere\n\n\n分组后筛选\n分组后的结果集\ngroup by子句的后面\nhaving\n\n\n\n1.分组函数做条件肯定放在having子句中\n2.能用分组前筛选的，尽量用分组前筛选\n\n\ngroup by子句支持单个字段分组，多个字段分组(多个字段之间用逗号隔开没有顺序要求)，表达式和函数\n也可以添加排序（排序放在分组查询最后）\n\n\n1.基本分组查询\n例1: 查询每个工种的最高工资\nSELECT\tMAX(salary),job_idFROM\temployeesGROUP BY\tjob_id;\n\n例2: 查询每个位置上的部门个数\nSELECT\tCOUNT(*),location_idFROM\tdepartmentsGROUP BY\tlocation_id;\n\n\n2.添加分组前的筛选条件\n例1: 查询邮箱中包含a的字符的，每个部门的平均工资\nSELECT\tAVG(salary),department_idFROM\temployeesWHERE\tdepartmen_id LIKE &#x27;%a%&#x27;GROUP BY\tdepartment_id;\n\n例2: 查询有奖金的每个领导手下员工的最高工资\nSELECT\tMAX(salary),manager_idFROM\temployeesWHERE\tcommission_pct IS NOT NULLGROUP BY\tmanager_id;\n\n\n3.添加分组后的筛选条件\nHAVING是对分组后的数据进行筛选\n\n例1: 查询哪个部门的员工个数&gt;2\n\n1.查询每个部门的员工个数\n\n2.根据1的结果进行筛选，查询哪个部门的员工个数&gt;2\nSELECT\tCOUNT(*),department_idFROM\temployeesGROUP BY\tdepartment_idHAVING\tCOUNT(*)&gt;2;\n\n例2: 查询每个工种有奖金的员工的最高的工资&gt;12000的工种编号和最高工资\nSELECT\tMAX(salary),job_idFROM\temployeesWHERE\tcommission_pct IS NOT NULLGROUP BY\tjob_idHAVING\tMAX(salary)&gt;12000;\n\n例3: 查询领导编号&gt;102的每个领导手下的最低工资&gt;5000的领导编号是哪个，以及最低工资\nSELECT\tMIN(salary),manager_idFROM\temployeesWHERE\tmanager_id&gt;102GROUP BY\tmanager_idHAVING\tMIN(salary)&gt;5000;\n\n\n4.按表达式或函数分组\n例: 按员工姓名的长度分组，查询每一组的员工个数，筛选员工个数&gt;5的有哪些SELECT\tCOUNT(*),LENGTH(last_name) AS 姓名长度FROM\temployeesGROUP BY\t姓名长度HAVING\tCOUNT(*)&gt;5;\n\n\n5.按多个字段分组\n例: 查询每个部门每个工种的员工的平均工资SELECT\tAVG(salary),department_id,job_idFROM\temployeesGROUP BY\tjob_id,department_id;#可以变换位置\n\n\n6.添加排序\n例: 查询每个部门每个工种的员工的平均工资，并且按平均工资的高低显示SELECT\tAVG(salary),department_id,job_idFROM\temployees#WHERE\tdepartment_id IS NOT NULLGROUP BY\tjob_id,department_id#HAVING\tAVG(salary)&gt;10000ORDER BY\tAVG(salary) DESC;\n\n","tags":["DQL语言"]},{"title":"基础查询：select语句","url":"/2022/01/28/2.DQL%E8%AF%AD%E8%A8%80/%E5%9F%BA%E7%A1%80%E6%9F%A5%E8%AF%A2%EF%BC%9Aselect%20%E8%AF%AD%E5%8F%A5/","content":"一、select 语句语法\nsql不区分大小写所以select和SELECT相同，但常用大写便于阅读。# USE 表名SELECT 查询列表 FROM 表名;\n\n\n二、查询列表的特点\n查询列表可以是：\n表中的字段&#x2F;列\n常量值\n表达式\n函数\n\n\n查询的结果是一个虚拟的表格\n\n\n三、select查询列表的具体方法1.查询单个列SELECT 列名 FROM 表名;\n\n\n2.查询多个列SELECT 列名,列名,列名 FROM 表名;\n\n最后一个列名不加“，”\n\n\n3.查询表中所有法一：写全列名SELECT \t列名,\t列名,\t列名,\t列名,\t列名,\t列名,\t列名FROM \t表名;\t#用``来区分关键字和名称\n法二：用通配符（ * ）SELECT * FROM 表名;\n\n缺点：顺序与表内顺序相同\n\n\n4.查询列中不同的值\n相当于去重\n例：列vend_id中有很多重复的行，则利用关键字 DISTINCT:\nDISTINCT关键词作用于该词后所有的列，而并非后面的第一个SELECT DISTINCT vend_id FROM Products;\n\n\n注意：不能一次性对多列去重，这样会使表不规则\n\n\n5.查询常量值SELECT 100;#数值型SELECT &quot;sawyer&quot;;#字符型\n\n注意：字符型和日期型的常量值必须用单或者双引号引起来，数值型不需要\n\n\n6.查询表达式SELECT 100%98;#计算表达式 取余=2\n\n注意：不支持++，–\n\n\n7.查询函数0.语法：SELECT 函数名(实参列表);#调用函数\n1.利用concat合并\n拼接字符SELECT CONCAT(&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;);#合并字符 abcSELECT \t\tCONCAT(列名1,列名2) AS 一二列 FROM \t\t表名;#合并列名1和列名2两列的数据\n2.利用ifnull来筛别列中null的行\n判断某字段或表达式是否为null，如果为null返回固定的值，否则返回原本的值SELECT \t\tIFNULL(列名1,数值或字符值)FROM \t\t表名;#如果列中有null则代替为数值或字符值\n\n3.利用isnull\n判断某字段段或表达式是否为null，如果为null返回1，否则返回0SELECT \t\tISNULL(参数列表)FROM \t\t表名;#如果列中有null则返回1，否则则返回0\n\n\n8.起别名1.利用AS起别名，对每一个列使用SELECT 100%98 AS 结果;#显示为：结果 2SELECT 列名1 AS 第一列,列名2 AS 第二列 FROM 表名;\n\n便于理解\n如果要查询的字段有重名，便于区分\n\n2.利用空格，直接写别名SELECT 列名1 第一列,列名2 第二列 FROM 表名;\n\n3.别名若是关键字，需用“ ”来区分SELECT 列名1 &quot;out put&quot; FROM 表名;SELECT 列名1 AS &quot;out put&quot; FROM 表名;\n\n\n9.+号的作用\nmysql中+号只有运算符的功能：SELECT 100+90;#两个操作数为数值型，则做加法运算SELECT &#x27;123&#x27;+90;#其中一方为字符型，试图将字符型转换为数值型；如果转换成功，则继续做加法运算#213SELECT &#x27;sawyer&#x27;+90;#如果转换成功，则将字符型数值转换为0#90SELECT null+90;#只要其中一方为null，则结果肯定为null#NULL\n\n\n10.限制查询结果\n利用关键字TOP来限制返回多少行SELECT TOP 5 列名 FROM 表名;#只返回列中前5行的数据\nDB2特有的sql语句 FETCH FIRST 行数  ROWS ONLY：SELECT 列名 FROM 表名FETCH FIRST 5 ROWS ONLY;\noracle需基于ROWNUM来计算行：SELECT 列名 FROM 表名WHERE ROWNUM &lt;=5;\nmysql，SQLite，PostgreSQL需使用LIMIT：\n\n\nLIMIT 行数来表示返回多少行SELECT 列名 FROM 表名LIMIT 5;\nLIMIT 行数 OFFSET 某开始行-1来表示返回多少行SELECT 列名 FROM 表名LIMIT 5 OFFSET 5;#检索从某行开始，则检索数：某行数-1\n\n\n简化形式：SELECT 列名 FROM 表名LIMIT 4,3;#逗号前为OFFSET后的数，逗号后为LIMIT后的数（与上一个是反着表示的）\n\n\n11.显示表的结构\n利用DESCDESC 表名;\n\n","tags":["DQL语言"]},{"title":"子查询","url":"/2022/02/12/2.DQL%E8%AF%AD%E8%A8%80/%E5%AD%90%E6%9F%A5%E8%AF%A2/","content":"一、子查询含义\n出现在其他语句中的SELECT语句，称为子查询或内查询\n外部的查询语句，称为主查询或外查询\n\n二、子查询分类\n按子查询出现的的位置：\nselect后面：\n仅仅支持标量子查询\n\n\nfrom后面：\n支持表子查询\n\n\nwhere或having后面：\n标量子查询\n列子查询\n行子查询\n\n\nexists后面（相关子查询）：\n表子查询\n\n\n\n\n按结果集的行列数不同：\n标量子查询（结果集只有一行一列）\n列子查询（结果集只有一列多行）\n行子查询（结果集有一行多列）\n表子查询（结果集一般为多行多列）\n\n\n\n一、where或having后面\n1.标量子查询（单行子查询）\n2.列子查询（多行子查询）\n3.行子查询（多列多行）\n特点：\n1.子查询放在小括号内\n2.子查询一般放在条件的右侧\n3.标量子查询，一般搭配着单行操作符使用（    &gt; &lt; &gt;&#x3D; &lt;&#x3D; &#x3D; &lt;&gt;）\n4.列子查询，一般搭配着多行操作符使用（IN、ANY&#x2F;SOME、ALL）\n5.子查询的执行优先于主查询执行，主查询的条件用到了子查询的结果1.标量子查询\n\n\n非法使用标量子查询：多行多列\n例1: 谁的工资比Abel高？SELECT last_name,salaryFROM employeesWHERE salary&gt;(SELECT salary FROM employees WHERE last_name=&#x27;Abel&#x27;);\n例2: 返回job_id与141号员工相同，salary比143号员工多的员工姓名，job_id和工资SELECT last_name,job_id,salaryFROM employeesWHERE salary&gt;(SELECT salary FROM employees WHERE employee_id=143) AND job_id=(SELECT job_id FROM employees WHERE employee_id=141);\n例3: 返回公司工资最少的last_name,job_id和salarySELECT last_name,job_id,salaryFROM employeesWHERE salary=(SELECT MIN(salary) FROM employees);\n例4: 查询最低工资大于50号部门最低工资的部门id和其最低工资SELECT MIN(salary)FROM employeesGROUP BY department_idHAVING MIN(salary)&gt;(\tSELECT MIN(salary) \tFROM employees \tWHERE department_id=50\tGROUP BY department_id);\n2.列子查询\n多行子查询（一列多行）\n使用多行比较操作符\n\n\n\n\n操作符\n含义\n\n\n\nIN&#x2F;NOT IN\n等于列表中的任意一个\n\n\nANY ｜SOME\n和子查询返回的某一个值比较\n\n\nALL\n和子查询返回的所有值比较\n\n\n\n例1：返回location_id是1400或1700的部门中的所有员工姓名\n#内连接SELECT last_name,location_idFROM employees eINNER JOIN departments dON e.department_id=d.department_idWHERE location_id IN(1400,1700);#列子查询SELECT last_nameFROM employeesWHERE department_id IN(SELECT department_id FROM departments WHERE location_id IN(1400,1700) );#department_id = ANY(SELECT department_id FROM departments WHERE location_id IN(1400,1700)),any包括in的功能\n\n例2：返回其他部门中比job_id为‘IT_PROG’部门任一工资低的员工的：工号、姓名、job_id以及salary\nSELECT employee_id,last_name,job_id,salaryFROM employeesWHERE salary&lt;(\tSELECT MAX(salary) \tFROM employees \tWHERE job_id=&#x27;IT_PROG&#x27;)AND job_id&lt;&gt;&#x27;IT_PROG&#x27;;#anySELECT employee_id,last_name,job_id,salaryFROM employeesWHERE salary&lt;ANY(\tSELECT DISTINCT salary\tFROM employees \tWHERE job_id=&#x27;IT_PROG&#x27;)AND job_id&lt;&gt;&#x27;IT_PROG&#x27;;\n例3：返回其他部门中比job_id为‘IT_PROG’部门所有工资低的员工的：工号、姓名、job_id以及salary\nSELECT employee_id,last_name,job_id,salaryFROM employeesWHERE salary&lt;ALL(\tSELECT DISTINCT salary\tFROM employees \tWHERE job_id=&#x27;IT_PROG&#x27;)AND job_id&lt;&gt;&#x27;IT_PROG&#x27;;\t#allSELECT employee_id,last_name,job_id,salaryFROM employeesWHERE salary&lt;(\tSELECT MIN(salary) \tFROM employees \tWHERE job_id=&#x27;IT_PROG&#x27;)AND job_id&lt;&gt;&#x27;IT_PROG&#x27;;\n3.行子查询（结果集一行多列或多行多列）\n例：查询员工编号最小并且工资最高的员工信息\nSELECT *FROM employeesHAVING employee_id=(\tSELECT MIN(employee_id)    FROM employees )AND salary=(\tSELECT MAX(salary)    FROM employees);#行子查询SELECT *FROM employeesWHERE (employee_id,salary)=(\tSELECT MIN(employee_id),MAX(salary)\tFROM employees);\n\n\n二、SELECT后面1.标量子查询\n例：查询每个部门的员工个数\nSELECT d.*,(\tSELECT COUNT(*) 员工个数    FROM employees e    WHERE e.department_id=d.department_id)FROM departments d;#外连接+分组SELECT d.*,COUNT(*) 个数FROM departments dLEFT JOIN employees eON d.department_id=e.department_idGROUP BY d.department_id;\n\n例2:查询员工号&#x3D;102的部门名\nSELECT (\tSELECT d.department_name\tFROM departments d\tINNER JOIN employees e\tON d.department_id=e.department_id\tWHERE e.employee_id=102) 部门名;#内连接SELECT d.department_name,e.employee_idFROM departments dINNER JOIN employees eON d.department_id=e.department_idWHERE e.employee_id=102;\n\n\n三、FROM后面1.表子查询\n例：查询每个部门的平均工资的工资等级SELECT ag_dep.*,g.grade_levelFROM(\tSELECT AVG(salary) ag,department_id\tFROM employees\tGROUP BY department_id) ag_depINNER JOIN job_grades gON ag_dep.ag BETWEEN lowest_sal AND highest_sal;#非等值内连接SELECT AVG(salary),department_id,grade_levelFROM employees eINNER JOIN job_grades gON e.salary BETWEEN lowest_sal AND highest_salGROUP BY department_id\n\n四、EXISTS后面（相关子查询）1.EXISTS使用\n语法：EXISTS(完整的查询语句);#结果为1或0\nSELECT EXISTS(SELECT employee_id FROM employees);#1是true，0是false\n例：查询员工名和部门名SELECT department_nameFROM departments dWHERE EXISTS(\tSELECT *    FROM employees e    WHERE d.department_id=e.department_id);\n例：查询没有女朋友的男神信息#inSELECT bo.*FROM boys boWHERE bo.id NOT IN(\tSELECT boyfriend_id    FROM beauty);#EXISTSSELECT bo.*FROM boys boWHERE NOT EXISTS(\tSELECT boyfriend_id     FROM beauty b\tWHERE bo.id=b.boyfriend_id);\n\n","tags":["DQL语言"]},{"title":"SQL中常见函数","url":"/2022/01/31/2.DQL%E8%AF%AD%E8%A8%80/%E5%B8%B8%E8%A7%81%E5%87%BD%E6%95%B0/","content":"一、函数的概念将一组逻辑语句封装在方法体中，对外暴露方法名\n\n二、函数封装的好处\n隐藏了实现细节    \n提高代码的充用性\n\n\n三、调用函数语法SELECT 函数名(实参列表) #FROM 表名;\n\n\n四、常见函数分类1.单行函数\n例：CONCAT()、LENGTH()、IFNULL()\n\n1.字符函数1.LENGTH()\n获取参数值的字节个数SELECT LENGTH(&#x27;sawyer&#x27;);#6SELECT LENGTH(&#x27;沈小鱼zuikeaiya&#x27;);#18 \n\n\n在UTF8下，一个字母1个字节，一个汉字3个字节\n在JBK下，一个字母1个字节，一个汉字2个字节\n\n2.CONCAT()\n拼接字符串SELECT CONCAT(last_name,&#x27;_&#x27;,first_name) AS 姓名 FROM employees;\n3.UPPER(),LOWER()\nUPPER()把字符串变成大写\nLOWER()把字符串变成小写SELECT UPPER(&#x27;sawyer&#x27;);#SAWYERSELECT LOWER(&#x27;SawyER&#x27;);#sawyer\n例：将姓变大写，名变小写，然后拼接SELECT CONCAT(UPPER(last_name),LOWER(first_name)) AS 姓名 FROM employees;\n4.SUBSTR()、SUBSTRING\n截取字符串\n注意：索引从1开始#截取从指定索引处后面所有字符SELECT SUBSTR(&#x27;袁湘琴爱上了江直树&#x27;,7) out_put;#江直树#截取从指定索引处指定字符长度的字符SELECT SUBSTR(&#x27;袁湘琴爱上了江直树&#x27;,1,3) out_put#其中3是长度\n例：姓名中首字符大写，其他字符小写，然后用_拼接，显示出来SELECT \t\tCONCAT(UPPER(SUBSTR(last_name,1,1)),&#x27;_&#x27;,LOWER(SUBSTR(last_name,2)),LOWER(first_name)) AS 姓名FROM \t\temployees;\n\n5.INSTR()\n返回子串第一次出现的索引，如果找不到返回0#截取从指定索引处后面所有字符SELECT INSTR(&#x27;袁湘琴爱上了江直树&#x27;,&#x27;江直树&#x27;) AS out_put;#7SELECT INSTR(&#x27;袁湘琴江直树爱上了江直树&#x27;,&#x27;江直树&#x27;) AS out_put;#4SELECT INSTR(&#x27;袁湘琴爱上了江直树&#x27;,&#x27;江玉树&#x27;) AS out_put;#0\n\n6.TRIM()\n去前后空格\nTRIM(指定元素 FROM 字符串)，用于去除字符串前后的指定元素SELECT LENGHT(TRIM(&#x27;      袁湘琴  &#x27;)) AS out_put;#9SELECT TRIM(&#x27;a&#x27; FROM &#x27;aaaaaa袁aaaaa湘琴aaaa&#x27;)) AS out_put;#袁aaaaa湘琴\n\n7.LPAD()\n用指定的字符来左填充指定长度SELECT LPAD(&#x27;袁湘琴&#x27;,10,&#x27;*&#x27;) AS out_put;#******袁湘琴SELECT LPAD(&#x27;袁湘琴&#x27;,2,&#x27;*&#x27;) AS out_put;#袁湘\n8.RPAD()\n用指定的字符来右填充指定长度SELECT RPAD(&#x27;袁湘琴&#x27;,10,&#x27;ab&#x27;) AS out_put;#袁湘琴abababababSELECT RPAD(&#x27;袁湘琴&#x27;,2,&#x27;ab&#x27;) AS out_put;#湘琴\n9.REPLACESELECT REPLACE(&#x27;袁湘琴爱上了江直树&#x27;,&#x27;江直树&#x27;,&#x27;钟汉良&#x27;) AS out_put;#袁湘琴爱上了钟汉良SELECT REPLACE(&#x27;袁湘琴爱上了江直树，江直树爱了爱了&#x27;,&#x27;江直树&#x27;,&#x27;钟汉良&#x27;) AS out_put;#袁湘琴爱上了钟汉良，钟汉良爱了爱了\n\n\n2.数学函数1.ROUND\n四舍五入SELECT ROUND(1.65);#2SELECT ROUND(-1.65);#-2#小数点后保留2位SELECT ROUND(1.56789,2);#1.57\nROUND(数值型)\nROUND(数值型,x),x为小数点后保留位数\n\n2.CEIL()\n向上取整，返回&gt;&#x3D;该参数的最小整数SELECT CEIL(1.0002);#2SELECT CEIL(1.00);#1SELECT CEIL(-1.0002);#-1\n3.FLOOR()\n向下取整，返回&lt;&#x3D;该参数的最大整数SELECT FLOOR(-9.99);#-10SELECT FLOOR(9.99);#9\n\n4.TRUNCATE\n截断SELECT TRUNCATE(1.5999,1);#1.5\n\n5.MOD\n取余\nMOD(a,b): a-a&#x2F;b * bSELECT MOD(10,3);#1SELECT MOD(10,-3);#1SELECT MOD(-10,3);#-1SELECT MOD(-10,-3);#-1#SELECT 10%3;\n6.RAND\n获取随机数，返回0-1之间的小数SELECT RAND();\n\n\n3.日期函数1.NOW()\n返回当前系统日期+时间SELECT NOW();#2022-01-29 15:16:46\n2.CURDATE()\n返回当前系统日期，不包含时间SELECT CURDATE();#2022-01-29\n3.CURTIME()\n返回当前时间，不包含日期SELECT CURTIME();#15:20:55\n4.可以获取指定的部分，年、月、日、小时、分钟、秒#年SELECT YEAR(NOW());#2022SELECT YEAR(&#x27;1998-1-1&#x27;);#1998SELECT YEAR(hiredate) 年 FROM employees;#月SELECT MONTH(NOW());#1SELECT MONTHNAME(NOW());#January英文显示#日SELECT DAY(NOW());#29#小时SELECT HOUR(NOW());#15#分钟SELECT MINUTE(NOW());#32#秒SELECT SECOND(NOW());#39\n\n5.STR_TO_DATE()\n将日期格式的字符转换成指定格式的日期SELECT STR_TO_DATE(&#x27;9-13-1999&#x27;,&#x27;%m-%d-%Y&#x27;);#1993-09-13\n日期格式符\n\n\n\n\n格式符\n功能\n\n\n\n%Y\n四位数的年份\n\n\n%y\n2位数的年份\n\n\n%m\n月份 (01,02,03,04,05,06,07,08,09,10,11,12)\n\n\n%c\n月份（1,2,3,4,5,6,7,8,9,10,11,12）\n\n\n%d\n日(01,02…)\n\n\n%H\n小时(24小时制)\n\n\n%h\n小时(24小时制)\n\n\n%i\n分钟(00,01,…59)\n\n\n%s\n秒(00,01,…59)\n\n\n-例：查询入职日期为1992-4-3的员工日期\n#法一：直接用条件查询筛选SELECT \t\t*FROM\t\temployeesWHERE\t\thiredate=&#x27;1992-4-3&#x27;;\t\t#法二：SELECT \t\t*FROM\t\temployeesWHERE\t\thiredate=STR_TO_DATE(&#x27;4-3 1992&#x27;,&#x27;%c-%d %Y&#x27;);\n6.DATE_FORMAT()\n将日期转换成字符SELECT DATE_FORMAT(&#x27;2018/6/6&#x27;,&#x27;%y年%m月%d日&#x27;);#18年06月06日\n查询有奖金的员工名和入职日期（xx月&#x2F;x日&#x2F;xx年）SELECT \t\tlast_name,DATE_FORMAT(hiredate,&quot;%m月/%d日 %y年&quot;) AS 入职日期FROM\t\temployeesWHERE\t\tcommission_pct IS NOT NULL;\t\t\n\n7.DATEDIFF()\n计算两个日期相差天数，前大后小SELECT DATEDIFF(&#x27;2022-1-29&#x27;,&#x27;2019-6-7&#x27;);#967\n\n4.其他函数1.VERSION()\n查看当前版本SELECT VERSION();#8.0.28\n2.DATABASE()\n查看当前数据库SELECT DATABASE();#&#x27;myemployees&#x27;\n3.USER()\n查看当前用户SELECT USER();#root@localhost\n4.PASSWORD(‘字符’)\n返回该字符的密码形式SELECT PASSWORD(&#x27;字符&#x27;);\n5.MD5(‘字符’)\n返回该字符的md5加密形式SELECT MD5(&#x27;字符&#x27;);\n5.流程控制函数1.if函数\nif else的效果SELECT IF(10&gt;5,&quot;大&quot;，&quot;小&quot;);#大\n查询员工是否有奖金，有奖金提示有，没奖金提示没有SELECT last_name,commission_pct,IF(commission_pct IS NULL,&quot;没奖金，呵呵&quot;，&quot;有奖金，嘻嘻&quot;) AS 备注 FROM employees;\n\n2.CASE()\n【使用1】： switch case在java中的效果：\nswitch(变量或表达式)&#123;\tcase 常量1: 语句1;break;\t....\t\tdefault:语句n;break;&#125;\n在mysql中case的表达\ncase 要判断的字段或表达式when 常量1 then 要显示的值1或语句1;when 常量2 then 要显示的值2或语句2;...else 要显示的值n或语句n;end\n例：查询与昂哦高的工资，要求：部门号&#x3D;30，显示的工资为1.1倍；部门号&#x3D;40，显示的工资为1.2倍；部门号&#x3D;50，显示的工资为1.3倍；其他部门，显示的工资为员工资\nSELECT salary 原始工资,department_id,CASE department_idWHEN 30 then salary*1.1WHEN 40 then salary*1.2WHEN 50 then salary*1.3ELSE salary END AS 新工资FROM employees;\n\n【使用2】：类似在java中的多重if\nif(条件1)&#123;\t\t语句1;&#125;else if(条件2)&#123;\t\t语句2;&#125;...else&#123;\t\t语句n;&#125;\n在mysql中\ncase when 条件1 then 要显示的值1或语句1;when 条件2 then 要显示的值2或语句2;...else 要显示的值n或语句n;end\n例：查询员工的工资情况，如果工资&gt;20000，显示A级别；如果工资&gt;15000,显示B级别；如果工资&#x3D;10000，显示C级别；否则，显示D级别\nSELECT last_name,salary,CASE WHEN salary&gt;20000 then &#x27;A&#x27;WHEN salary&gt;15000 then &#x27;B&#x27;WHEN salary&gt;10000 then &#x27;C&#x27;ELSE &#x27;D&#x27;END AS 工资级别FROM employeesORDER BY salary DESC;\n\n\n2.分组函数\n功能：做统计使用，又称为统计函数，聚函数，组函数\n和分组函数一同查询的字段，一般要求是GROUP BY后的字段，其他都不行1.求和SUM\n可以对数值型进行处理\nnull不参与运算\n可以利用DISTINCT去重SELECT SUM(salary) FROM employees;\n\n2.求平均AVG\n可以对数值型进行处理\nnull不参与运算\n可以利用DISTINCT去重SELECT AVG(salary) FROM employees;\n3.最大值MAX\n可以对字符型和数值型进行比较\n字符型按照排序比大小\nnull不参与运算\n可以利用DISTINCT去重SELECT MAX(salary) FROM employees;\n4.最小值MIN\n可以对字符型和数值型进行比较\n字符型按照排序比大小\nnull不参与运算\n可以利用DISTINCT去重SELECT MIN(salary) FROM employees;\n5.计算个数COUNT\n非空计数\n可以对不为null的任意型\n可以利用DISTINCT去重\n一般用count(* )用作统计行数\n\n\nINNODB存储引擎下，count(* )和count(1)，比count(字段)要高\nMYISAM存储引擎下，count(* )效率最高\n\nSELECT COUNT(salary) FROM employees;#统计总行数SELECT COUNT(*) FROM employees;#count里加一列常量值，可以用于统计个数SELECT COUNT(1) FROM employees;\n","tags":["DQL语言"]},{"title":"排序查询数据：ORDER BY子句","url":"/2022/01/30/2.DQL%E8%AF%AD%E8%A8%80/%E6%8E%92%E5%BA%8F%E6%9F%A5%E8%AF%A2%E6%95%B0%E6%8D%AE%EF%BC%9AORDER%20BY%E5%AD%90%E5%8F%A5/","content":"一、排序查询语法SELECT\t\t\t查询列表FROM\t\t表名#WHERE \t筛选条件ORDER BY\t\t\t排序列表 #ASC/DESC;\n\n执行顺序：FROM -&gt;WHERE-&gt;SELECT-&gt;ORDER BY\n\n\n二、排序查询的具体方法\n特点：\nASC代表的是升序，DESC代表的是降序；如果不写，默认是升序\nORDER BY子句中可以支持单个字段和多个字段、表达式、函数、别名\nORDER BY子句一般放在查询语句最后，limit子句除外\n\n\n\n1.普通排序\n例1：查询员工信息，要求工资从高到低实现排序SELECT\t\t\t*FROM\t\temployeesORDER BY\t\t\tsalary DESC;#从高到低\t\t#salary ASC;#从低到高，去掉ASC也是从低到高排序\n\n\n2.添加筛选条件排序\n例2：查询部门编号&gt;&#x3D;90的员工信息，按入职时间的先后进行排序SELECT\t\t\t*FROM\t\temployeesWHERE\t\tdepartment_id&gt;=90ORDER BY\t\t\thiredate ASC;\n\n\n3.按表达式排序\n例3：按年薪的高低显示员工的信息和年薪SELECT\t\t\t*,salary*12*(1+IFNULL(commission_pct,0)) AS 年薪FROM\t\temployeesORDER BY\t\t\tsalary*12*(1+IFNULL(commission_pct,0)) DESC;\t\t#年薪 DESC;#也可以写成这种形式\n表达式的别名可以直接在ORDER BY后使用\n\n\n4.按函数排序\n例4：按姓名的长度显示员工的姓名和工资SELECT\t\t\tLENGTH(last_name) AS 字节长度,last_name,salaryFROM\t\temployeesORDER BY\t\tLENGTH(last_name) DESC;\t\t#字节长度 DESC;和上一句相等\n\n\n5.按多个列排序\n例4：查询员工信息，要求先按工资排序，再按员工编号排序SELECT\t\t\t*FROM\t\temployeesORDER BY\t\tsalary ASC,employee_id DESC;\n\n","tags":["DQL语言"]},{"title":"过滤数据：条件查询where子句","url":"/2022/01/29/2.DQL%E8%AF%AD%E8%A8%80/%E8%BF%87%E6%BB%A4%E6%95%B0%E6%8D%AE%EF%BC%9A%E6%9D%A1%E4%BB%B6%E6%9F%A5%E8%AF%A2where%E5%AD%90%E5%8F%A5/","content":"一、WHERE条件查询语法SELECT \t\t查询列表 FROM \t\t表名WHERE\t\t筛选条件;\n\n执行顺序：先FRONM，再WHERE，再SELECT\n\n\n二、筛选条件的分类1.条件运算符\n\n\n操作符\n说明\n\n\n\n&#x3D;\n等于\n\n\n&lt;&gt;\n不等于\n\n\n!&#x3D;\n不等于\n\n\n&lt;\n小于\n\n\n&lt;&#x3D;\n小于等于\n\n\n!&lt;\n不小于\n\n\n&gt;\n大于\n\n\n&gt;&#x3D;\n大于等于\n\n\n!&gt;\n不大于\n\n\n\n例1：查询工资&gt;12000的员工信息SELECT \t\t*FROM \t\temployeesWHERE\t\tsalary&gt;12000;\n例2: 查询部门编号不等于90号的员工名和部门编号SELECT \t\tlast_name,\t\tdepartment_idFROM \t\temployeesWHERE\t\tdepartment_id&lt;&gt;90;\n例3: 查询员工号为176的员工的姓名和部门编号和年薪SELECT \t\tlast_name,        employee_id,\t\tdepartment_id,\t\tsalary*12*(1+IFNULL(commission_pct,0)) AS 年薪FROM \t\temployeesWHERE\t\temployee_id=176;\n\n\n2.逻辑运算符\n\n\n操作符\n英文含义\n含义\n\n\n\n&amp;&amp;\nAND\n都true则true\n\n\n｜｜\nOR\n一true则true\n\n\n！\nNOT\n取反\n\n\n\n例1: 查询工资z在10000到20000之间的员工名、工资及奖金SELECT \t\tlast_name,\t\tsalary,\t\tcommission_pctFROM \t\temployeesWHERE\t\tsalary&lt;=20000&amp;&amp;salary&gt;=10000;\t\t#salary&lt;=20000 AND salary&gt;=10000;这两句相等\n例2: 查询部门编号不是在90到110之间，或者工资高于15000的员工信息SELECT \t\t*FROM \t\temployeesWHERE\t\tNOT(department_id&gt;=90 AND department_id&lt;=110) OR salary&gt;15000;\t\t#department_id&lt;90 OR department_id&gt;110 OR salary&gt;=15000;以上这两句相等\t\t#department_id NOT BETWEEN 90 AND 110与NOT(department_id&gt;=90 AND department_id&lt;=110)相等\nNOT(c AND b)与NOT BETWEEN c AND b相等\n\n\n3.模糊查询1. like关键字\n一般和通配符搭配使用，可以判断字符型或数值型\n\n%表示任意多个字符，包含0个字符\n_ 表示任意单个字符\n用\\l来转义字符，也可以用关键字ESCAPE来指定符号作为转义字符\n\n\n例1: 查询员工名中包含字符a的员工信息\nSELECT \t\t*FROM \t\temployeesWHERE\t\tlast_name LIKE \t&#x27;%a%&#x27;;#单双引号都可以\n例2: 查询员工名中第三个字符为n，第五个字符为l的员工名和工资\nSELECT \t\tlast_name,\t\tsalaryFROM \t\temployeesWHERE\t\tlast_name LIKE \t&#x27;__n_l%&#x27;;\n例3: 查询员工名中第二个字符为_的员工名\nSELECT \t\tlast_nameFROM \t\temployeesWHERE\t\tlast_name LIKE \t&#x27;_a_%&#x27; ESCAPE &quot;a&quot;;#利用ESCAPE转义\t\t#last_name LIKE &#x27;_\\_%&#x27;;直接用\\转义\n例4: 查询employees表中，job_id不为“IT”或者工资为12000的员工信息\nSELECT \t\t*FROM \t\temployeesWHERE\t\tjob_id NOT LIKE &#x27;%IT%&#x27; OR salary=12000;\n例5: 查询employess表中，部门编号为1开头的三位数\nSELECT \t\t*FROM \t\temployeesWHERE\t\tdepartment_id LIKE &#x27;1__&#x27;;#这里不能用&#x27;1%&#x27;，因为指定了是三位数，而&#x27;1%&#x27;也可能为两位数\n\n注意区分：\n#区分这两个是不一样的SELECT * FROM employees;SELECT * FROM employees WHERE commission_pct LIKE &#x27;%%&#x27; AND last_name LIKE &#x27;%%&#x27;;#这个里null的值会被忽略，如果AND换成OR，则两个结果一样\n2. between and关键字\n\n\n使用between and可以提高语句的简洁度\n包含临界值\n两个临界值不要调换位置\n\n\n例1: 查询员工编号在100到120之间的员工信息SELECT \t\t*FROM \t\temployeesWHERE\t\temployee_id BETWEEN 100 AND 120;\t\t#employee_id&gt;=100 AND employee_id&lt;=120;\n3. in关键字\n用于判断某字段的值是否属于in列表中的某一项\n特点：\n使用in提高语句简洁度‘\nin列表的值类型必须统一或兼容\n不支持通配符\n\n\n例1: 查询员工的工种编号是IT_PROG、AD_VP、AD_PRES中的一个员工名和工种编号SELECT \t\tlast_name,\t\tjob_idFROM \t\temployeesWHERE\t\tjob_id IN(&quot;IT_PROG&quot;,&quot;AD_VP&quot; ,&quot;AD_PRES&quot;);         #job_id = &quot;IT_PROG&quot; OR job_id=&quot;AD_VP&quot; OR job_id=&quot;AD_PRES&quot;;这两句意思相同\n4. is null关键字\n\n\n&#x3D;或&lt;&gt;不能用于判断null值\nis null或is not null可以判断null值\n\n\n例1: 查询没有奖金的员工名和奖金率SELECT \t\tlast_name,\t\tcommission_pctFROM \t\temployeesWHERE\t\tcommission_pct IS NULL;\n例2: 查询有奖金的员工名和奖金率SELECT \t\tlast_name,\t\tcommission_pctFROM \t\temployeesWHERE\t\tcommission_pct IS NOT NULL;\n\n\n4.安全等于&lt; &#x3D; &gt;\n例1: 查询没有奖金的员工名和奖金率SELECT \t\tlast_name,\t\tcommission_pctFROM \t\temployeesWHERE\t\tcommission_pct &lt;=&gt; NULL;\n例2: 查询工资为12000的员工信息SELECT \t\tlast_name,\t\tsalaryFROM \t\temployeesWHERE\t\tsalary &lt;=&gt; 12000;\nIS NULL 和&lt; &#x3D; &gt;的区别和特点\n\n\n\n\nIS NULL\n仅可以判断null值，可读性较高，建议使用\n\n\n\n&lt; &#x3D; &gt;\n既可以判断null值，又可以判断普通的数值，可读性较低\n\n\n","tags":["DQL语言"]},{"title":"连接查询：多表查询","url":"/2022/02/06/2.DQL%E8%AF%AD%E8%A8%80/%E8%BF%9E%E6%8E%A5%E6%9F%A5%E8%AF%A2%EF%BC%9A%E5%A4%9A%E8%A1%A8%E6%9F%A5%E8%AF%A2/","content":"一、连接查询的语法\n又称“多表查询”，当查询的字段来自于多个表时，就会用到连接查询SELECT * FROM beauty;SELECT * FROM boys;SELECT NAME,boyNAME FROM boys,beauty;#一个name对应全部的boyname\n此时犯了笛卡尔集的错误情况：SELECT COUNT(*) FROM beauty;#假设输出12行SELECT COUNT(*) FROM boys;#假设输出4行#最终结果：12*4=48行\n笛卡尔乘积现象：表1 有m行，表2 有n行，结果&#x3D;m* n行\n发生原因：没有有效的连接条件\n如何避免：添加有效的连接条件\n\n\n\nSELECT NAME,boyNAME FROM boys,beautyWHERE beauty.boyfriend_id=boys.id;\n\n\n二、连接查询的分类\n按年代分类：\nsql92标准\nsql99标准\n\n\n按功能分类：\n内连接\n等值连接\n非等值连接\n自连接\n\n\n外连接\n左外连接\n右外连接\n全外连接\n交叉连接一、sql92标准\n\n\n\n\nmysql中仅仅支持内连接\n\n内连接1.等值连接\n多表等值连接的结果为多表的交集部分\nn表连接，至少需要n-1个连接条件\n多表的顺序没有要求\n一般需要为表起别名\n可以搭配所有子句使用，比如排序，分组，筛选\n\n0.语法：SELECT 查询列表 FROM 表1 别名,表2 别名WHERE 表1.key=表2.key【AND 筛选条件】【GROUP BY 分组字段】【HAVING 分组后的筛选】【ORDER BY 排序字段】;\n\n例1：查询女神名和对应的男神名SELECT NAME,boyNAME FROM boys,beautyWHERE beauty.boyfriend_id=boys.id;\n例2：查询员工名和对应的部门名SELECT last_name,department_nameFROM employees,departmentsWHERE employees.department_id=departments.department_id;\n1.为表起别名\n1.提高语句的简洁度\n2.区分多个重名的字段\n注意：如果为表起了别名，则查询的字段就不能使用原来的表名去限定\n例：查询员工名、工种号、工种名SELECT e.last_name,e.job_id,j.job_titleFROM employees AS e,jobs AS jWHERE e.job_id=j.job_id;\n两个表的顺序可以调换\n\n2.添加筛选\n例1: 查询有奖金的员工名、部门名SELECT e.last_name,department_name,commission_pctFROM employees e,departments dWHERE e.department_id=d.department_idAND e.commission_pct IS NOT NULL;\n例2: 查询城市名中第二个字符为o的部门名和城市名SELECT department_name,cityFROM departments d,locations lWHERE d.location_id=l.location_idAND city LIKE &#x27;_o%&#x27;;\n\n3.添加分组查询\n例1: 查询每个城市的部门个数SELECT d.COUNT(*) AS 个数,cityFROM departments d,locations lWHERE d.location_id=l.location_idGROUP BY city;\n例2: 查询有奖金的每个部门的部门名和部门的领导编号和该部门的最低工资SELECT d.department_name,e.manager_id,MIN(salary)FROM departments d,employees eWHERE d.department_id=e.department_id AND e.commission_pct IS NOT NULLGROUP BY department_name;\n\n4.添加排序\n例: 查询每个工种的工种名和员工的个数，并且按员工个数降序SELECT job_title,COUNT(*) 员工个数FROM jobs j,employees eWHERE e.job_id=j.job_idGROUP BY job_titleORDER BY 员工个数 DESC;\n\n5.三表连接\n例: 查询员工名、部门名和所在的城市SELECT last_name,department_name,cityFROM locations l,employees e,departments dWHERE e.department_id=d.department_id AND d.location_id=l.location_id;\n\n2.非等值连接0.语法：SELECT 查询列表 FROM 表1 别名,表2 别名WHERE 非等值连接条件【AND 筛选条件】【GROUP BY 分组字段】【HAVING 分组后的筛选】【ORDER BY 排序字段】;\n\n例：查询员工的工资和工资级别SELECT salary,grade_levelFROM employees e,job_grade gWHERE salary BWTWEEN g.lowest_sal AND g.highest_salAND g.grade_level=&#x27;A&#x27;;\n\n3.自连接0.语法：SELECT 查询列表 FROM 表 别名1,表 别名2WHERE 别名1.key=别名2.key【AND 筛选条件】【GROUP BY 分组字段】【HAVING 分组后的筛选】【ORDER BY 排序字段】;\n\n例：查询员工名和上级的名称SELECT e.last_name,e.employee_id,m.last_name,m.employee_idFROM employees e,employees mWHERE e.manager_id=m.employee_id;\n\n\n二、sql99标准【推荐】\n支持内连接+外连接（左外和右外）+交叉连接\n\n\n语法SELECT 查询列表 FROM 表1 别名【连接类型】JOIN 表2 别名 ON\t连接条件 【WHERE 筛选条件】【GROUP BY 分组字段】【HAVING 分组后的筛选】【ORDER BY 排序字段】;\n分类表示\n\n\n内连接：inner (交集)\n外连接\n左外：left 【outer】(左表全集)\n右外：right【outer】(右表全集)\n全外：full【outer】(并集)\n\n\n交叉连接 ：cross一、内连接\n语法：SELECT 查询列表 FROM 表1 别名INNER JOIN 表2 别名 ON\t连接条件 ;\n特点：\n1.添加排序、分组、筛选\n2.inner可以省略\n3.筛选条件放在where后面，连接条件放在on后面，提高分离性，便于阅读\n4.inner join连接和sql92连接语法中的等值连接效果是一样的，都是查询多表的交集\n\n\nA和B-&gt;A∩BSELECT 查询列表 FROM AINNER JOIN BON\tA.key=B.key ;\n1.等值连接\n例1：查询员工名、部门名SELECT last_name,department_nameFROM employees eINNER JOIN department dON\te.department_id=d.department_id;\n例2：查询名字中包含e的员工名和工种名（添加筛选）SELECT last_name,job_titleFROM employees eINNER JOIN jobs jON\te.job_id=j.job_idWHERE last_name LIKE &#x27;%e%&#x27;;\n例3：查询部门个数&gt;3的城市名和部门个数（添加分组+筛选）SELECT city,COUNT(*) 部门个数FROM departments dINNER JOIN locations lON\td.location_id=l.location_idGROUP BY cityHAVING  COUNT(*)&gt;3;\n例4：查询哪个部门的员工个数&gt;3的部门名和员工个数，并按个数降序（添加排序）SELECT department_name,COUNT(*) 员工个数FROM employees eINNER JOIN departments dON\te.department_id=d.department_idGROUP BY department_nameHAVING  COUNT(*)&gt;3ORDER BY COUNT(*) DESC;\n例5：查询员工名、部门名、工种名、并按部门名降序（三表连接）SELECT last_name,department_name,job_titleFROM employees eINNER JOIN departments d ON e.department_id=d.department_idINNER JOIN jobs j ON e.job_id=j.job_idORDER BY department_name DESC;\n2.非等值连接\n例1: 查询员工的工资级别SELECT salary,grade_levelFROM employees eINNER JOIN job_grades g ON e.salary BETWEEN g.lowest_sal AND g.highest_sal;\n例2: 查询每个工资级别&gt;20的个数，并且按工资级别降序SELECT COUNT(*),grade_levelFROM employees eINNER JOIN job_grades g ON e.salary BETWEEN g.lowest_sal AND g.highest_salGROUP BY grade_levelHAVING COUNT(*)&gt;20ORDER BY grade_level DESC;\n\n3.自连接\n例1：查询员工的名字、上级的名字SELECT e.last_name,m.last_nameFROM employees eINNER JOIN employees mON e.manager_id=m.employee_id;\n例2：查询姓名中包含字符k的员工的名字、上级的名字SELECT e.last_name,m.last_nameFROM employees eINNER JOIN employees mON e.manager_id=m.employee_idWHERE e.last_name LIKE &#x27;%k%&#x27;;\n\n二、外连接\n应用场景：用于查询一个表中有，另一个表中没有\n\n特点：\n\n1.外连接的查询结果为主表中的所有记录。\n如果从表中有和它匹配的，则显示匹配的值\n如果从表中没有和它匹配的，则显示null\n外连接查询结果&#x3D;内连接结果+主表中有而从表没有的记录\n\n\n2.左外连接，left join 左边的是主表 \n3.右外连接，right join右边的是主表\n4.左外和右外交换两个表的顺序，可以实现同样的效果\n5.全外连接&#x3D;内连接的结果+表1中有但表2没有的+表2中有但表1没有的1.左（右）外连接\n\n\nA和B-&gt;左A全：\nSELECT 查询列表 FROM ALEFT JOIN BON  A.key=B.key;\nA和B-&gt;右B全：\nSELECT 查询列表 FROM ARIGHT JOIN BON  A.key=B.key;\nA和B-&gt;B-A&#x3D;BĀ：\n#左外SELECT 查询列表 FROM BLEFT JOIN AON  A.key=B.keyWHERE A.key IS NULL;#右外SELECT 查询列表 FROM ARIGHT JOIN BON  A.key=B.keyWHERE A.key IS NULL;\n例1：查询男朋友，不在男神表的女神名\n#右外连接SELECT b.nameFROM boys boRIGHT OUTER JOIN beauty bON b.boyfriend_id = bo.idWHERE bo.id IS NULL;#一般int型不为null#左外连接SELECT b.nameFROM beauty bLEFT OUTER JOIN boys boON b.boyfriend_id = bo.idWHERE bo.id IS NULL;#一般int型不为null\n\n例2：查询哪个部门没有员工\n#左外SELECT d.*,e.employee_idFROM departments dLEFT OUTER JOIN employees eON d.department_id=e.department_idWHERE e.employee_id IS NULL;#右外SELECT d.*,e.employee_idFROM employees eRIGHT OUTER JOIN departments dON d.department_id=e.department_idWHERE e.employee_id IS NULL;\n\n2.全外连接\nMySQL，SQLite不支持FULL OUTER JOINT\nA和B-&gt;A∪B：SELECT 查询列表 FROM AFULL JOIN BON\tA.key=B.key ;\nA和B-&gt;A∪B-AB&#x3D;AB逆-ĀB：SELECT 查询列表 FROM AFULL JOIN BON\tA.key=B.keyWHERE A.key IS NULL OR B.key IS NULL;\n例1：查询男朋友，女神名SELECT b.*,bo.*FROM beauty bFULL OUTER JOIN boys boON b.boyfriend_id = bo.id;\n\n三、交叉连接\n笛卡尔乘积\n例1：查询男朋友，女神名SELECT b.*,bo.*FROM beauty bCROSS OUTER JOIN boys bo;\n\n","tags":["DQL语言"]}]